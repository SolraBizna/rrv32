use super::*;

use std::fmt::{Debug, Formatter, Result as FmtResult};

#[cfg(feature="float")]
mod float;
#[cfg(not(feature="float"))]
/// Stub of the float module, to allow us to continue having that type
/// parameter and the skeleton of that CSR.
mod float {
    pub trait FloatBits : Copy + Default {
        const SUPPORT_F: bool = false;
        const SUPPORT_D: bool = false;
        const SUPPORT_Q: bool = false;
        type CsrType;
        fn default_csr() -> Self::CsrType;
        fn read_csr(_: &Self::CsrType) -> u32;
        fn write_csr(_: &mut Self::CsrType, _: u32);
    }
    impl FloatBits for () {
        type CsrType = ();
        fn default_csr() {}
        fn read_csr(_: &()) -> u32 { 0 }
        fn write_csr(_: &mut Self::CsrType, _: u32) {}
    }
}
pub use float::FloatBits;
#[cfg(feature="float")]
use float::*;
#[cfg(feature="float")]
use rustc_apfloat::{Float, FloatConvert, ieee::{Single, Double, Quad}, Status, StatusAnd};

/// Exceptions that can occur during execution of an instruction. Values
/// correspond to `mcause` values.
#[repr(i32)]
#[derive(Debug)]
#[allow(unused)]
pub enum ExceptionCause {
    MisalignedPC=0,
    InstructionFault=1,
    IllegalInstruction=2,
    Breakpoint=3,
    MisalignedLoad=4,
    LoadFault=5,
    MisalignedStore=6,
    StoreFault=7,
    EcallFromUmode=8,
    EcallFromSmode=9,
    EcallFromMmode=11,
    InstructionPageFault=12,
    LoadPageFault=13,
    StorePageFault=15,
}

/// A trap generated by an instruction.
#[repr(C)]
pub struct Exception {
    /// The cause of the exception.
    pub mcause: ExceptionCause,
    /// The PC of the instruction that failed because of the exception. (Note:
    /// if the fault is from a misaligned PC, this is the address of the
    /// instruction that was causing the PC to become misaligned, NOT the
    /// address it was jumping to)
    pub mepc: u32,
    /// For `\*Fault` and `Misaligned\*` exceptions, this is the address whose
    /// access caused the exception. For `IllegalInstruction`, this is the
    /// instruction word that was illegal. For all other exceptions, this is
    /// 0.
    pub mtval: u32,
}

impl Debug for Exception {
    fn fmt(&self, f: &mut Formatter<'_>) -> FmtResult {
        write!(f, "Exception {{ mcause: {:?}, mepc: {:08X}, mtval: {:08X} }}",
            self.mcause, self.mepc, self.mtval)
    }
}

#[repr(C)]
pub struct Cpu<F: FloatBits = ()> {
    registers: [u32; 32], // pc is stored where x0 would be
    float_registers: [F; 32],
    fcsr: F::CsrType,
}

fn alu_op(alt: bool, op: u32, a: u32, b: u32) -> Result<u32,ExceptionCause> {
    Ok(match op {
        0b000 => {
            match alt {
                false => a.wrapping_add(b),
                true => a.wrapping_sub(b),
            }
        }
        0b001 => {
            if alt { return Err(ExceptionCause::IllegalInstruction) }
            a << (b & 0b11111)
        }
        0b010 => {
            if alt { return Err(ExceptionCause::IllegalInstruction) }
            if (a as i32) < (b as i32) { 1 } else { 0 }
        }
        0b011 => {
            if alt { return Err(ExceptionCause::IllegalInstruction) }
            if a < b { 1 } else { 0 }
        }
        0b100 => {
            if alt { return Err(ExceptionCause::IllegalInstruction) }
            a ^ b
        }
        0b101 => {
            if alt { ((a as i32) >> (b & 0b11111)) as u32 }
            else { a >> (b & 0b11111) }
        }
        0b110 => {
            if alt { return Err(ExceptionCause::IllegalInstruction) }
            a | b
        }
        0b111 => {
            if alt { return Err(ExceptionCause::IllegalInstruction) }
            a & b
        }
        _ => unreachable!()
    })
}

impl<F: FloatBits> Cpu<F> {
    pub fn new() -> Cpu<F> {
        Cpu {
            registers: [0; 32],
            float_registers: Default::default(),
            fcsr: F::default_csr(),
        }
    }
    /// Return the current value of the PC, i.e. the instruction that will be
    /// executed by the next `step`.
    pub fn get_pc(&self) -> u32 { return self.registers[0] }
    /// Change the current value of the PC. The pointed-to instruction will be
    /// executed by the next `step`.
    ///
    /// The low bit is IGNORED. The second lowest bit will cause an immediate
    /// OUT-OF-SPEC unaligned instruction exception if the C extension is not
    /// supported. (It's out of spec because the unaligned instruction
    /// exception's `mepc` is supposed to indicate the address of the branch or
    /// jump that *would have* caused the trap, but if you `put_pc` a
    /// misaligned value, it will contain the misaligned value instead.)
    pub fn put_pc(&mut self, new_pc: u32) { self.registers[0] = new_pc & !1; }
    /// Get the value of a general purpose register, in the range 0-31.
    /// Register 0 always returns 0.
    pub fn get_register(&self, index: u32) -> u32 {
        if index >= 1 && index < 32 {
            self.registers[index as usize]
        }
        else if index == 0 {
            0
        }
        else {
            panic!("register {index} out of range")
        }
    }
    /// Change the value of a general purpose register, in the range 0-31.
    /// Setting register 0 is a no-op.
    pub fn put_register(&mut self, index: u32, value: u32) {
        if index >= 1 && index < 32 {
            self.registers[index as usize] = value;
        }
        else if index == 0 {
            // do nothing
        }
        else {
            panic!("register {index} out of range")
        }
    }
    fn perform_amo<Env: ExecutionEnvironment>(&mut self, env: &mut Env, amop: u32, rd: u32, rs1: u32, rs2: u32, _aq: bool, _rl: bool, orig_instruction: u32) -> Result<(),(ExceptionCause,u32)> {
        let addr = self.get_register(rs1);
        // |mem, reg| -> mem
        let amop: fn(u32, u32) -> u32 = match amop {
            0b00000 => |mem, reg| {
                // AMOADD.W
                mem + reg
            },
            0b00001 => |_mem, reg| {
                // AMOSWAP.W
                reg
            },
            0b00010 if rs2 == 0 => {
                // LR.W
                let result = map_load(addr, env.load_reserved_word(addr))?;
                self.put_register(rd, result);
                return Ok(())
            },
            0b00011 => {
                // SC.W
                let src = self.get_register(rs2);
                let result = match map_store(addr, env.store_reserved_word(addr, src))? {
                    false => 1, // store failed!
                    true => 0, // store succeeded!
                };
                self.put_register(rd, result);
                return Ok(())
            },
            0b00100 => |mem, reg| {
                // AMOXOR.W
                mem ^ reg
            },
            0b01100 => |mem, reg| {
                // AMOAND.W
                mem & reg
            },
            0b01000 => |mem, reg| {
                // AMOOR.W
                mem | reg
            },
            0b10000 => |mem, reg| {
                // AMOMIN.W
                ((mem as i32).min(reg as i32)) as u32
            },
            0b10100 => |mem, reg| {
                // AMOMAX.W
                ((mem as i32).max(reg as i32)) as u32
            },
            0b11000 => |mem, reg| {
                // AMOMINU.W
                mem.min(reg)
            },
            0b11100 => |mem, reg| {
                // AMOMAXU.W
                mem.max(reg)
            },
            _ => return Err((ExceptionCause::IllegalInstruction, orig_instruction))
        };
        let src = self.get_register(rs2);
        // yes, map_store, because AMOs produce store exceptions even if it is
        // the first access that faults
        let oldmem = map_store(addr, env.read_word(addr, !0))?;
        let newmem = amop(oldmem, src);
        map_store(addr, env.write_word(addr, newmem, !0))?;
        self.put_register(rd, oldmem);
        Ok(())
    }
    /// Error result is `(mcause, mtval)`.
    fn internal_step<Env: ExecutionEnvironment>(&mut self, env: &mut Env) -> Result<(), (ExceptionCause, u32)> {
        let this_pc = self.get_pc();
        let orig_instruction = map_ifetch(this_pc, env.read_instruction(this_pc))?;
        env.account_ifetch(this_pc);
        #[cfg(feature="C")]
        let (orig_instruction, instruction, mut next_pc) = if orig_instruction & 0b11 != 0b11 {
            // It's a 16-bit instruction!
            if !Env::SUPPORT_C || !env.enable_c() {
                return Err((ExceptionCause::IllegalInstruction, orig_instruction))
            }
            // Decode it
            // (see below comment about lexically scoped macros)
            let orig_instruction = orig_instruction & 0xFFFF;
            macro_rules! illegal {
                () => {return Err((ExceptionCause::IllegalInstruction, orig_instruction)) };
            }
            macro_rules! extracted {
                (($hi:literal .. $lo:literal)) => {
                    { (orig_instruction >> $lo) & ((1<<($hi+1-$lo))-1) }
                };
                ((~$hi:literal .. $lo:literal)) => {
                    ((orig_instruction >> $lo) & ((1<<($hi-$lo))-1)) | (if (orig_instruction >> $hi) & 1 != 0 { !0 << ($hi-$lo) } else { 0 })
                };
                ($x:expr) => { $x };
            }
            macro_rules! extract {
                ($($x:tt),+) => {
                    ($(extracted!($x)),+)
                };
            }
            macro_rules! inserted {
                ($input:expr => $outbit:literal) => {
                    { $input << $outbit }
                };
                ($input:expr => ($hi:literal $lo:literal)) => {
                    (($input) & (((1<<($hi+1-$lo))-1)) << $outbit)
                };
            }
            macro_rules! assemble {
                ($start:literal, $($input:tt->$output:tt),+) => {
                    { $start $( | inserted!(extracted!($input) => $output))+ }
                };
            }
            let decoded_instruction: u32 = match extract!((15..13), (1..0)) {
                (0b000, 0b00) => { // ADDI4SPN
                    let offset = assemble!(0, (12..11)->4, (10..7)->6, (6..6)->2, (5..5)->3);
                    if offset == 0 { illegal!() }
                    let rd = extract!((4..2))+8;
                    self.put_register(rd, self.get_register(2).wrapping_add(offset));
                    env.account_generic_op();
                    self.put_pc(this_pc.wrapping_add(2));
                    return Ok(())
                },
                (0b001, 0b00) => { // FLD
                    let offset = assemble!(0, (12..10)->3, (6..5)->6);
                    let (rs1, rd) = extract!((9..7), (4..2));
                    assemble!(0b011_00000_0000111, (rs1+8)->15, (rd+8)->7, offset->20)
                },
                (0b010, 0b00) => { // LW
                    let offset = assemble!(0, (12..10)->3, (6..6)->2, (5..5)->6);
                    let (rs1, rd) = extract!((9..7), (4..2));
                    assemble!(0b010_00000_0000011, (rs1+8)->15, (rd+8)->7, offset->20)
                },
                (0b011, 0b00) => { // FLW
                    let offset = assemble!(0, (12..10)->3, (6..6)->2, (5..5)->6);
                    let (rs1, rd) = extract!((9..7), (4..2));
                    assemble!(0b010_00000_0000111, (rs1+8)->15, (rd+8)->7, offset->20)
                },
                (0b101, 0b00) => { // FSD
                    let offset = assemble!(0, (12..10)->3, (6..5)->6);
                    let (rs1, rs2) = extract!((9..7), (4..2));
                    assemble!(0b010_00000_0100111, (rs1+8)->15, (rs2+8)->20, (offset>>5)->25, (offset&0b11111)->7)
                },
                (0b110, 0b00) => { // SW
                    let offset = assemble!(0, (12..10)->3, (6..6)->2, (5..5)->6);
                    let (rs1, rs2) = extract!((9..7), (4..2));
                    assemble!(0b010_00000_0100011, (rs1+8)->15, (rs2+8)->20, (offset>>5)->25, (offset&0b11111)->7)
                },
                (0b111, 0b00) => { // FSW
                    let offset = assemble!(0, (12..10)->3, (6..6)->2, (5..5)->6);
                    let (rs1, rs2) = extract!((9..7), (4..2));
                    assemble!(0b010_00000_0100111, (rs1+8)->15, (rs2+8)->20, (offset>>5)->25, (offset&0b11111)->7)
                },
                (0b000, 0b01) => { // ADDI
                    let rd = extract!((11..7));
                    let imm = assemble!(0, (~12..12)->5, (6..2)->0);
                    self.put_register(rd, self.get_register(rd).wrapping_add(imm));
                    self.put_pc(self.get_pc().wrapping_add(2));
                    env.account_generic_op();
                    return Ok(())
                },
                (0b001, 0b01) => { // JAL
                    // what the
                    let imm = assemble!(0, (~12..12)->11, (11..11)->4, (10..9)->8, (8..8)->10, (7..7)->6, (6..6)->7, (5..3)->1, (2..2)->5);
                    self.put_register(1, this_pc.wrapping_add(2));
                    self.put_pc(self.get_pc().wrapping_add(imm) & !1);
                    env.account_jump_op();
                    return Ok(())
                },
                (0b010, 0b01) => { // LI
                    let imm = assemble!(0, (~12..12)->5, (6..2)->0);
                    let rd = extract!((11..7));
                    self.put_register(rd, imm);
                    self.put_pc(this_pc.wrapping_add(2));
                    env.account_generic_op();
                    return Ok(())
                },
                (0b011, 0b01) => {
                    let rd = extract!((11..7));
                    if rd == 2 { // ADDI16SP
                        let imm = assemble!(0, (~12..12)->9, (6..6)->4, (5..5)->6, (4..3)->7, (2..2)->5);
                        self.put_register(2, self.get_register(2).wrapping_add(imm));
                        self.put_pc(this_pc.wrapping_add(2));
                        env.account_generic_op();
                        return Ok(())
                    } else { // LUI
                        let imm = assemble!(0, (~12..12)->17, (6..2)->12);
                        if imm == 0 { illegal!() }
                        self.put_register(rd, imm);
                        self.put_pc(this_pc.wrapping_add(2));
                        env.account_generic_op();
                        return Ok(())
                    }
                },
                (0b100, 0b01) => { // arithmetic operations!
                    let (funct2, rd) = extract!((11..10), (9..7));
                    let rd = rd + 8;
                    match funct2 {
                        0 => { // SRLI
                            if extract!((12..12)) != 0 { illegal!() }
                            let amt = extract!((6..2));
                            self.put_register(rd, self.get_register(rd) >> amt as i32);
                            self.put_pc(this_pc.wrapping_add(2));
                            env.account_generic_op();
                            return Ok(())
                        },
                        1 => { // SRAI
                            if extract!((12..12)) != 0 { illegal!() }
                            let amt = extract!((6..2));
                            self.put_register(rd, (self.get_register(rd) as i32 >> amt as i32) as u32);
                            self.put_pc(this_pc.wrapping_add(2));
                            env.account_generic_op();
                            return Ok(())
                        },
                        2 => { // ANDI
                            let imm = assemble!(0, (~12..12)->5, (6..2)->0);
                            self.put_register(rd, self.get_register(rd)&imm);
                            self.put_pc(this_pc.wrapping_add(2));
                            env.account_generic_op();
                            return Ok(())
                        },
                        3 => { // and the rest
                            let (op, rs2) = extract!((6..5), (4..2));
                            let rs2 = rs2 + 8;
                            match op {
                                0 => self.put_register(rd, self.get_register(rd).wrapping_sub(self.get_register(rs2))), // SUB
                                1 => self.put_register(rd, self.get_register(rd)^ self.get_register(rs2)), // XOR
                                2 => self.put_register(rd, self.get_register(rd) | self.get_register(rs2)), // OR
                                3 => self.put_register(rd, self.get_register(rd) & self.get_register(rs2)), // AND
                                _ => illegal!(),
                            }
                            self.put_pc(this_pc.wrapping_add(2));
                            env.account_generic_op();
                            return Ok(())
                        },
                        _ => unreachable!(),
                    }
                },
                (0b101, 0b01) => { // J
                    let imm = assemble!(0, (~12..12)->11, (11..11)->4, (10..9)->8, (8..8)->10, (7..7)->6, (6..6)->7, (5..3)->1, (2..2)->5);
                    self.put_pc(this_pc.wrapping_add(imm) & !1);
                    env.account_jump_op();
                    return Ok(())
                },
                (0b110, 0b01) => { // BEQZ
                    let rs1 = extract!((9..7))+8;
                    if self.get_register(rs1) == 0 {
                        let offset = assemble!(0, (~12..12)->8, (11..10)->3, (6..5)->6, (4..3)->1, (2..2)->5);
                        self.put_pc(this_pc.wrapping_add(offset));
                        env.account_branch_op(true, offset & 0x80000000 == 0);
                    } else {
                        self.put_pc(this_pc.wrapping_add(2));
                        env.account_branch_op(false, orig_instruction & (1<<12) != 0);
                    }
                    return Ok(())
                },
                (0b111, 0b01) => { // BNEZ
                    let rs1 = extract!((9..7))+8;
                    if self.get_register(rs1) != 0 {
                        let offset = assemble!(0, (~12..12)->8, (11..10)->3, (6..5)->6, (4..3)->1, (2..2)->5);
                        self.put_pc(this_pc.wrapping_add(offset));
                        env.account_branch_op(true, offset & 0x80000000 == 0);
                    } else {
                        self.put_pc(this_pc.wrapping_add(2));
                        env.account_branch_op(false, orig_instruction & (1<<12) != 0);
                    }
                    return Ok(())
                },
                (0b000, 0b10) => { // SLLI
                    if extract!((12..12)) != 0 { illegal!() }
                    let (rd, shamt) = extract!((11..7), (6..2));
                    self.put_register(rd, self.get_register(rd) << shamt as i32);
                    self.put_pc(this_pc.wrapping_add(2));
                    env.account_generic_op();
                    return Ok(())
                },
                (0b001, 0b10) => { // FLDSP
                    let rs = 2;
                    let rd = extract!((11..7));
                    let offset = assemble!(0, (12..12)->5, (6..5)->3, (4..2)->6);
                    assemble!(0b011_00000_0000111, offset->20, rd->7, rs->15)
                },
                (0b010, 0b10) => { // LWSP
                    let rs = 2;
                    let rd = extract!((11..7));
                    if rd == 0 { illegal!() }
                    let offset = assemble!(0, (12..12)->5, (6..4)->2, (3..2)->6);
                    assemble!(0b010_00000_0000011, offset->20, rd->7, rs->15)
                },
                (0b011, 0b10) => { // FLWSP
                    let rs = 2;
                    let rd = extract!((11..7));
                    let offset = assemble!(0, (12..12)->5, (6..4)->2, (3..2)->6);
                    assemble!(0b010_00000_0000111, offset->20, rd->7, rs->15)
                },
                (0b100, 0b10) => {
                    let (twelve, rs1, rs2) = extract!((12..12), (11..7), (6..2));
                    match (twelve, rs1, rs2) {
                        (0, rs1, 0) => { // JR
                            if rs1 == 0 { illegal!() }
                            self.put_pc(self.get_register(rs1) & !1);
                            env.account_jump_op();
                            return Ok(())
                        },
                        (0, rd, rs2) => { // MV
                            debug_assert!(rs2 != 0);
                            self.put_register(rd, self.get_register(rs2));
                            self.put_pc(this_pc.wrapping_add(2));
                            env.account_generic_op();
                            return Ok(())
                        },
                        (1, 0, 0) => { // EBREAK
                            0b000000000001_00000_000_00000_111011
                        },
                        (1, rs1, 0) => { // JALR
                            debug_assert!(rs1 != 0);
                            let dst = self.get_register(rs1);
                            self.put_register(1, this_pc.wrapping_add(2));
                            self.put_pc(dst & !1);
                            env.account_jump_op();
                            return Ok(())
                        },
                        (1, rd, rs2) => { // ADD
                            assemble!(0b0110011, rd -> 7, rd -> 15, rs2 -> 20)
                        },
                        _ => unreachable!(),
                    }
                },
                (0b101, 0b10) => { // FSDSP
                    let rs = 2;
                    let rd = extract!((6..2));
                    let offset = assemble!(0, (12..10)->3, (9..7)->6);
                    assemble!(0b011_00000_0100111, rd -> 20, rs -> 15, (offset >> 5) -> 25, (offset & 0b11111) -> 7)
                },
                (0b110, 0b10) => { // SWSP
                    let rs = 2;
                    let rd = extract!((6..2));
                    let offset = assemble!(0, (12..9)->2, (8..7)->6);
                    assemble!(0b010_00000_0100011, rd -> 20, rs -> 15, (offset >> 5) -> 25, (offset & 0b11111) -> 7)
                },
                (0b111, 0b10) => { // FSWSP
                    let rs = 2;
                    let rd = extract!((6..2));
                    let offset = assemble!(0, (12..9)->2, (8..7)->6);
                    assemble!(0b010_00000_0100111, rd -> 20, rs -> 15, (offset >> 5) -> 25, (offset & 0b11111) -> 7)
                },
                _ => illegal!()
            };
            // 16-bit instructions are 2 bytes long
            (orig_instruction, decoded_instruction, this_pc.wrapping_add(2))
            // 32-bit instructions are 4 bytes long
        } else { (orig_instruction, orig_instruction, this_pc.wrapping_add(4)) };
        #[cfg(not(feature="C"))]
        if Env::SUPPORT_C && env.enable_c() { panic!("Your crate skipped compiling RV32C support but then enabled it!") }
        #[cfg(not(feature="C"))]
        let (instruction, orig_instruction, mut next_pc) = (orig_instruction, orig_instruction, this_pc.wrapping_add(4));
        let opcode = (instruction >> 2) & 0b11111;
        // I don't want to calculate these when they're not used, but I don't
        // want to repeat myself either. Fortunately for me, yesterday I
        // learned that Rust's macro identifier hygiene rules includes lexical
        // scope!
        macro_rules! illegal {
            () => { return Err((ExceptionCause::IllegalInstruction, orig_instruction)) };
        }
        macro_rules! funct3 { () => { (instruction >> 12) & 0b111 }; }
        macro_rules! funct7 { () => { (instruction >> 25) & 0b1111111 }; }
        macro_rules! rs1 { () => { (instruction >> 15) & 0b11111 }; }
        macro_rules! rs2 { () => { (instruction >> 20) & 0b11111 }; }
        macro_rules! rd { () => { (instruction >> 7) & 0b11111 }; }
        macro_rules! imm12 { () => { ((instruction as i32) >> 20) as u32 }; }
        macro_rules! imm12s { () => {
            (((instruction as i32) >> 20) as u32 & !0b11111)
            | (((instruction as i32) >> 7) as u32 & 0b11111)
        }; }
        macro_rules! imm20 { () => { instruction & 0xFFFFF000 }; }
        macro_rules! imm_j { () => {
            {
                let imm_10_1 = (instruction >> 21) & 0b1111111111;
                let imm_11 = (instruction >> 20) & 0b1;
                let imm_19_12 = (instruction >> 12) & 0b11111111;
                let imm_20 = (instruction as i32) >> 31;
                (imm_10_1 << 1)
                | (imm_11 << 11)
                | (imm_19_12 << 12)
                | (imm_20 << 20) as u32
            }
        };}
        macro_rules! imm_b { () => {
            {
                let imm_4_1 = (instruction >> 8) & 0b1111;
                let imm_10_5 = (instruction >> 25) & 0b111111;
                let imm_11 = (instruction >> 7) & 0b1;
                let imm_12 = ((instruction as i32) >> 31);
                (imm_4_1 << 1)
                | (imm_10_5 << 5)
                | (imm_11 << 11)
                | (imm_12 << 12) as u32
            }
        };}
        #[allow(unused_macros)]
        macro_rules! fprecision { () => { (instruction >> 25) & 3 } }
        #[allow(unused_macros)]
        macro_rules! rs3 { () => { instruction >> 27 }}
        // like imm12, but without sign extension
        #[allow(unused_macros)]
        macro_rules! csr { () => { instruction >> 20 } }
        #[allow(unused_macros)]
        macro_rules! frs1 { () => { self.float_registers[rs1!() as usize] } }
        #[allow(unused_macros)]
        macro_rules! frs2 { () => { self.float_registers[rs2!() as usize] } }
        #[allow(unused_macros)]
        macro_rules! frs3 { () => { self.float_registers[rs3!() as usize] } }
        #[allow(unused_macros)]
        macro_rules! frd { ($value:expr) => { self.float_registers[rd!() as usize] = $value } }
        #[allow(unused_macros)]
        macro_rules! float_inputs_single {
            () => {
            };
            ($a:ident) => {
                let $a = float::to_single(F::unbox_single(frs1!()));
            };
            ($a:ident, $b:ident) => {
                let $a = float::to_single(F::unbox_single(frs1!()));
                let $b = float::to_single(F::unbox_single(frs2!()));
            };
            ($a:ident, $b:ident, $c:ident) => {
                let $a = float::to_single(F::unbox_single(frs1!()));
                let $b = float::to_single(F::unbox_single(frs2!()));
                let $c = float::to_single(F::unbox_single(frs3!()));
            };
        }
        #[allow(unused_macros)]
        macro_rules! float_inputs_double {
            () => {
            };
            ($a:ident) => {
                let $a = float::to_double(F::unbox_double(frs1!()));
            };
            ($a:ident, $b:ident) => {
                let $a = float::to_double(F::unbox_double(frs1!()));
                let $b = float::to_double(F::unbox_double(frs2!()));
            };
            ($a:ident, $b:ident, $c:ident) => {
                let $a = float::to_double(F::unbox_double(frs1!()));
                let $b = float::to_double(F::unbox_double(frs2!()));
                let $c = float::to_double(F::unbox_double(frs3!()));
            };
        }
        #[allow(unused_macros)]
        macro_rules! float_inputs_quad {
            () => {
            };
            ($a:ident) => {
                let $a = float::to_quad(F::unbox_quad(frs1!()));
            };
            ($a:ident, $b:ident) => {
                let $a = float::to_quad(F::unbox_quad(frs1!()));
                let $b = float::to_quad(F::unbox_quad(frs2!()));
            };
            ($a:ident, $b:ident, $c:ident) => {
                let $a = float::to_quad(F::unbox_quad(frs1!()));
                let $b = float::to_quad(F::unbox_quad(frs2!()));
                let $c = float::to_quad(F::unbox_quad(frs3!()));
            };
        }
        #[allow(unused_macros)]
        macro_rules! round_mode {
            () => {{
                let rm = funct3!();
                let rm = if rm == 0b111 { (F::read_csr(&self.fcsr) >> 5) & 0b111 } else { rm };
                match rm {
                    0b000 => rustc_apfloat::Round::NearestTiesToEven,
                    0b001 => rustc_apfloat::Round::TowardZero,
                    0b010 => rustc_apfloat::Round::TowardNegative,
                    0b011 => rustc_apfloat::Round::TowardPositive,
                    0b100 => rustc_apfloat::Round::NearestTiesToAway,
                    // invalid rounding mode, whether dynamic or static, is an
                    // illegal instruction
                    _ => illegal!(),
                }
            }};
        }
        #[allow(unused_macros)]
        macro_rules! float_op {
            ($T:ident; $($o:ident),* = $($i:ident),*; $code:block) => {{
                #[allow(unused)] use float::Float;
                match fprecision!() {
                    0b00 if F::SUPPORT_F && env.enable_f() => {
                        #[allow(unused)] type $T = float::Single;
                        float_inputs_single!($($i),*);
                        $(#[allow(unused_mut)] let mut $o;),*
                        $code;
                        $(
                            let $o = float::maybe_unstatus(self, $o);
                            if $o.is_nan() {
                                frd!(F::box_single(float::CANON_NAN_32));
                            } else {
                                frd!(F::box_single($o.to_bits() as u32));
                            }
                        ),*
                    }
                    0b01 if F::SUPPORT_D && env.enable_d() => {
                        #[allow(unused)] type $T = float::Double;
                        float_inputs_double!($($i),*);
                        $(#[allow(unused_mut)] let mut $o;),*
                        $code;
                        $(
                            let $o = float::maybe_unstatus(self, $o);
                            if $o.is_nan() {
                                frd!(F::box_double(float::CANON_NAN_64));
                            } else {
                                frd!(F::box_double($o.to_bits() as u64));
                            }
                        ),*
                    }
                    0b11 if F::SUPPORT_Q && env.enable_q() => {
                        #[allow(unused)] type $T = float::Quad;
                        float_inputs_quad!($($i),*);
                        $(#[allow(unused_mut)] let mut $o;),*
                        $code;
                        $(
                            let $o = float::maybe_unstatus(self, $o);
                            if $o.is_nan() {
                                frd!(F::box_quad(float::CANON_NAN_128));
                            } else {
                                frd!(F::box_quad($o.to_bits() as u128));
                            }
                        ),*
                    }
                    _ => illegal!()
                }
            }};
        }
        #[allow(unused_macros)]
        macro_rules! fbox {
            (Single) => {F::box_single};
            (Double) => {F::box_double};
            (Quad) => {F::box_quad};
        }
        #[allow(unused_macros)]
        macro_rules! funbox {
            (Single) => {F::unbox_single};
            (Double) => {F::unbox_double};
            (Quad) => {F::unbox_quad};
        }
        #[allow(unused_macros)]
        macro_rules! fap {
            (Single) => {Single};
            (Double) => {Double};
            (Quad) => {Quad};
        }
        #[allow(unused_macros)]
        macro_rules! ftoap {
            (Single) => {float::to_single};
            (Double) => {float::to_double};
            (Quad) => {float::to_quad};
        }
        #[allow(unused_macros)]
        macro_rules! fbits {
            (Single) => {u32};
            (Double) => {u64};
            (Quad) => {u128};
        }
        #[allow(unused_macros)]
        macro_rules! fcvt {
            ($from:ident -> $to:ident) => {
                let a = funbox!($from)(self.float_registers[rs1!() as usize]);
                let mut entrocrime = false;
                let o: StatusAnd<fap!($to)> = ftoap!($from)(a).convert_r(round_mode!(), &mut entrocrime);
                self.float_registers[rd!() as usize] = fbox!($to)(float::maybe_unstatus(self, o).to_bits() as fbits!($to));
            }
        }
        match opcode {
            0b00000 => {
                // LOAD
                let sign_extend = funct3!() & 0b100 == 0;
                let base = self.get_register(rs1!());
                let address = base.wrapping_add(imm12!());
                let result = match funct3!() & 0b11 {
                    0b00 => {
                        let b = map_load(address, env.read_byte(address))?;
                        if sign_extend { b as i8 as u32 }
                        else { b as u32 }
                    }
                    0b01 => {
                        let h = map_load(address, env.read_half(address))?;
                        if sign_extend { h as i16 as u32 }
                        else { h as u32 }
                    }
                    0b10 => {
                        map_load(address, env.read_word(address, !0))?
                    }
                    _ => {
                        illegal!()
                    }
                };
                self.put_register(rd!(), result);
                env.account_memory_load(address);
            }
            #[cfg(feature="float")]
            0b00001 if F::SUPPORT_F && env.enable_f() && funct3!() == 0b010 => {
                // FLW
                let base = self.get_register(rs1!());
                let address = base.wrapping_add(imm12!());
                let result = map_load(address, env.read_word(address, !0))?;
                frd!(F::box_single(result));
                env.account_memory_load(address);
            }
            #[cfg(feature="float")]
            0b00001 if F::SUPPORT_D && env.enable_d() && funct3!() == 0b011 => {
                // FLD
                let base = self.get_register(rs1!());
                let address = base.wrapping_add(imm12!());
                let little_word = map_load(address, env.read_word(address, !0))?;
                // we are intentionally not adding 4 to the exception address!
                let big_word = map_load(address, env.read_word(address.wrapping_add(4), !0))?;
                let words = ((big_word as u64) << 32) | (little_word as u64);
                frd!(F::box_double(words));
                env.account_memory_double_load(address);
            }
            #[cfg(feature="float")]
            0b00001 if F::SUPPORT_Q && env.enable_q() && funct3!() == 0b100 => {
                // FLQ?
                let base = self.get_register(rs1!());
                let address = base.wrapping_add(imm12!());
                let words = [
                    map_load(address, env.read_word(address, !0))?,
                    map_load(address, env.read_word(address.wrapping_add(4), !0))?,
                    map_load(address, env.read_word(address.wrapping_add(8), !0))?,
                    map_load(address, env.read_word(address.wrapping_add(12), !0))?,
                ];
                let words
                    = (words[3] as u128) << 96
                    | (words[2] as u128) << 64
                    | (words[1] as u128) << 32
                    | (words[0] as u128);
                frd!(F::box_quad(words));
                env.account_memory_quad_load(address);
            }
            0b00011 => {
                match funct3!() {
                    0b000 => {
                        // FENCE
                        // (treat as no-op)
                    }
                    0b001 if env.enable_zifence() => {
                        // FENCE.I from Zifence
                        // (treat as no-op)
                    }
                    _ => {
                        illegal!()
                    }
                }
            }
            0b00100 => {
                // OP-IMM
                let op = funct3!();
                let alt = op == 0b101 && (instruction & (1 << 30)) != 0;
                let a = self.get_register(rs1!());
                let b = imm12!();
                self.put_register(rd!(), alu_op(alt, op, a, b).map_err(|x| (x, orig_instruction))?);
                env.account_alu_op();
            }
            0b00101 => {
                // AUIPC
                self.put_register(rd!(), this_pc.wrapping_add(imm20!()));
                env.account_alu_op();
            }
            0b01000 => {
                // STORE
                let base = self.get_register(rs1!());
                let address = base.wrapping_add(imm12s!());
                let word = self.get_register(rs2!());
                match funct3!() {
                    0b000 =>
                        map_store(address, env.write_byte(address, word as u8))?,
                    0b001 =>
                    map_store(address, env.write_half(address, word as u16))?,
                    0b010 =>
                    map_store(address, env.write_word(address, word, !0))?,
                    _ => illegal!()
                }
                env.account_memory_store(address);
            }
            #[cfg(feature="float")]
            0b01001 if F::SUPPORT_F && env.enable_f() && funct3!() == 0b010 => {
                // FSW
                let base = self.get_register(rs1!());
                let address = base.wrapping_add(imm12s!());
                let word = F::unbox_single(frs2!());
                map_store(address, env.write_word(address, word, !0))?;
                env.account_memory_store(address);
            }
            #[cfg(feature="float")]
            0b01001 if F::SUPPORT_D && env.enable_d() && funct3!() == 0b011 => {
                // FSD
                let base = self.get_register(rs1!());
                let address = base.wrapping_add(imm12s!());
                let words = F::unbox_double(frs2!());
                map_store(address, env.write_word(address, words as u32, !0))?;
                // we are intentionally not adding 4 to the exception address!
                map_store(address, env.write_word(address.wrapping_add(4), (words >> 32) as u32, !0))?;
                env.account_memory_double_store(address);
            }
            #[cfg(feature="float")]
            0b01001 if F::SUPPORT_Q && env.enable_q() && funct3!() == 0b100 => {
                // FSQ?
                let base = self.get_register(rs1!());
                let address = base.wrapping_add(imm12s!());
                let words = F::unbox_quad(frs2!());
                map_store(address, env.write_word(address, words as u32, !0))?;
                map_store(address, env.write_word(address.wrapping_add(4), (words >> 32) as u32, !0))?;
                map_store(address, env.write_word(address.wrapping_add(8), (words >> 64) as u32, !0))?;
                map_store(address, env.write_word(address.wrapping_add(12), (words >> 96) as u32, !0))?;
                env.account_memory_double_store(address);
            }
            0b01011 if Env::SUPPORT_A && env.enable_a() && funct3!() == 0b010 => {
                // (AMO)
                let amop = instruction >> 27;
                let aq = instruction & (1<<26) != 0;
                let rl = instruction & (1<<26) != 0;
                self.perform_amo(env,amop,rd!(),rs1!(),rs2!(),aq,rl,orig_instruction)?;
                env.account_amo_op();
            }
            0b01100 => {
                // (OP)
                let a = self.get_register(rs1!());
                let b = self.get_register(rs2!());
                let result = match funct7!() {
                    0b0000000 => {
                        let x = alu_op(false, funct3!(), a, b).map_err(|x| (x, orig_instruction))?;
                        env.account_alu_op();
                        x
                    },
                    0b0100000 => {
                        let x = alu_op(true, funct3!(), a, b).map_err(|x| (x, orig_instruction))?;
                        env.account_alu_op();
                        x
                    },
                    0b0000001 if Env::SUPPORT_M && env.enable_m() => match funct3!() {
                        0b000 => {
                            // MUL
                            env.account_mul_op();
                            a.wrapping_mul(b)
                        },
                        0b001 => {
                            // MULH
                            env.account_mul_op();
                            ((a as i32 as u64).wrapping_mul(b as i32 as u64) >> 32) as u32
                        },
                        0b010 => {
                            // MULHSU
                            env.account_mul_op();
                            ((a as i32 as u64).wrapping_mul(b as u64) >> 32) as u32
                        },
                        0b011 => {
                            // MULHU
                            env.account_mul_op();
                            ((a as u64).wrapping_mul(b as u64) >> 32) as u32
                        },
                        0b100 => {
                            // DIV
                            env.account_div_op();
                            if b == 0 { !0 }
                            else { ((a as i32) / (b as i32)) as u32 }
                        },
                        0b101 => {
                            // DIVU
                            env.account_div_op();
                            if b == 0 { !0 }
                            else { (a / b) as u32 }
                        },
                        0b110 => {
                            // REM
                            env.account_div_op();
                            if b == 0 { a }
                            else { ((a as i32) % (b as i32)) as u32 }
                        },
                        0b111 => {
                            // REMU
                            env.account_div_op();
                            if b == 0 { a }
                            else { (a % b) as u32 }
                        },
                        _ => unreachable!(),
                    },
                    _ => return Err((ExceptionCause::IllegalInstruction,orig_instruction))
                };
                self.put_register(rd!(), result);
            }
            0b01101 => {
                // (LUI)
                self.put_register(rd!(), imm20!());
                env.account_generic_op();
            }
            #[cfg(feature="float")]
            0b10000 => {
                // FMADD.{S,D,Q}
                float_op!(T; o = a, b, c; {
                    o = a.mul_add_r(b, c, round_mode!());
                    env.account_float_ternop(T::get_word_count());
                });
            }
            #[cfg(feature="float")]
            0b10001 => {
                // FMSUB.{S,D,Q}
                float_op!(T; o = a, b, c; {
                    o = a.mul_add_r(b, -c, round_mode!());
                    env.account_float_ternop(T::get_word_count());
                });
            }
            #[cfg(feature="float")]
            0b10010 => {
                // FNMADD.{S,D,Q}
                float_op!(T; o = a, b, c; {
                    o = a.mul_add_r(-b, -c, round_mode!());
                    env.account_float_ternop(T::get_word_count());
                });
            }
            #[cfg(feature="float")]
            0b10011 => {
                // FNMSUB.{S,D,Q}
                float_op!(T; o = a, b, c; {
                    o = a.mul_add_r(-b, c, round_mode!());
                    env.account_float_ternop(T::get_word_count());
                });
            }
            #[cfg(feature="float")]
            0b10100 => {
                // most float ops
                match rs3!() {
                    0b00000 => float_op!(T; o = a, b; {
                        o = a.add_r(b, round_mode!()); // FADD.{S,D,Q}
                        env.account_float_binop(T::get_word_count());
                    }),
                    0b00001 => float_op!(T; o = a, b; {
                        o = a.sub_r(b, round_mode!()); // FSUB.{S,D,Q}
                        env.account_float_binop(T::get_word_count());
                    }),
                    0b00010 => float_op!(T; o = a, b; {
                        o = a.mul_r(b, round_mode!()); // FMUL.{S,D,Q}
                        env.account_float_binop(T::get_word_count());
                    }),
                    0b00011 => float_op!(T; o = a, b; {
                        // FDIV.{S,D,Q}
                        if a.is_nan() || b.is_nan() {
                            o = StatusAnd { value: T::NAN, status: if a.is_signaling() || b.is_signaling() { Status::INVALID_OP } else { Status::OK } };
                        } else if b.is_zero() {
                            if a.is_zero() {
                                o = StatusAnd { value: T::NAN, status: Status::INVALID_OP };
                            } else {
                                let out_sign = a.is_negative() != b.is_negative();
                                if out_sign {
                                    o = StatusAnd { value: -T::INFINITY, status: Status::DIV_BY_ZERO };
                                } else {
                                    o = StatusAnd { value: T::INFINITY, status: Status::DIV_BY_ZERO };
                                }
                            }
                        } else {
                            o = a.div_r(b, round_mode!());
                        }
                        // Bug in APFloat?
                        if a.is_finite() && b.is_finite() && o.value.is_infinite() && !o.status.contains(Status::DIV_BY_ZERO) {
                            o.status |= Status::OVERFLOW;
                        }
                        env.account_float_divide(T::get_word_count());
                    }),
                    0b01011 if rs2!() == 0 => {
                        // FSQRT.{S,D,Q}
                        let a = self.float_registers[rs1!() as usize];
                        let o = match fprecision!() {
                            0b00 => {
                                // single
                                let a = F::unbox_single(a);
                                let (result, iterations) = if env.use_accurate_single_sqrt(){
                                    ieee_apsqrt::sqrt_accurate(a, round_mode!())
                                } else {
                                    ieee_apsqrt::sqrt_fast(a, round_mode!())
                                };
                                env.account_sqrt(1, iterations);
                                F::box_single(float::maybe_unstatus(self, result))
                            },
                            0b01 => {
                                // double
                                let a = F::unbox_double(a);
                                let (result, iterations) = if env.use_accurate_single_sqrt(){
                                    ieee_apsqrt::sqrt_accurate(a, round_mode!())
                                } else {
                                    ieee_apsqrt::sqrt_fast(a, round_mode!())
                                };
                                env.account_sqrt(2, iterations);
                                F::box_double(float::maybe_unstatus(self, result))
                            },
                            0b11 => {
                                // quad
                                let a = F::unbox_quad(a);
                                let (result, iterations) = if env.use_accurate_single_sqrt(){
                                    illegal!()
                                } else {
                                    ieee_apsqrt::sqrt_fast(a, round_mode!())
                                };
                                env.account_sqrt(4, iterations);
                                F::box_quad(float::maybe_unstatus(self, result))
                            },
                            _ => illegal!(),
                        };
                        self.float_registers[rd!() as usize] = o;
                        env.account_generic_op();
                    },
                    0b00100 => {
                        let op: fn(bool,bool)->bool = match funct3!() {
                            0b000 => |_,b| { b }, // FSGNJ
                            0b001 => |_,b| { !b }, // FSGNJN
                            0b010 => |a,b| { a != b}, // FSGNJX
                            _ => illegal!(),
                        };
                        let a = self.float_registers[rs1!() as usize];
                        let b = self.float_registers[rs2!() as usize];
                        match fprecision!() {
                            0b00 => {
                                // single
                                let a = F::unbox_single(a);
                                let b = F::unbox_single(b);
                                let asign = a >> 31 != 0;
                                let bsign = b >> 31 != 0;
                                let osign = op(asign, bsign);
                                let o = (a & (u32::MAX >> 1)) | ((osign as u32) << 31);
                                self.float_registers[rd!() as usize] = F::box_single(o);
                            },
                            0b01 => {
                                // double
                                let a = F::unbox_double(a);
                                let b = F::unbox_double(b);
                                let asign = a >> 63 != 0;
                                let bsign = b >> 63 != 0;
                                let osign = op(asign, bsign);
                                let o = (a & (u64::MAX >> 1)) | ((osign as u64) << 63);
                                self.float_registers[rd!() as usize] = F::box_double(o);
                            },
                            0b11 => {
                                // quad
                                let a = F::unbox_quad(a);
                                let b = F::unbox_quad(b);
                                let asign = a >> 127 != 0;
                                let bsign = b >> 127 != 0;
                                let osign = op(asign, bsign);
                                let o = (a & (u128::MAX >> 1)) | ((osign as u128) << 127);
                                self.float_registers[rd!() as usize] = F::box_quad(o);
                            },
                            _ => illegal!(),
                        }
                        env.account_generic_op();
                    },
                    0b00101 => { // FMIN/FMAX
                        match funct3!() {
                            0b000 => float_op!(T; o = a, b; {
                                if a.is_nan() {
                                    o = b;
                                } else if b.is_nan() {
                                    o = a;
                                } else if a.is_zero() && b.is_zero() {
                                    if a.is_negative() { o = a }
                                    else { o = b }
                                } else {
                                    o = a.min(b);
                                }
                                if a.is_signaling() || b.is_signaling() {
                                    self.accrue_float_exceptions(INVALID_FLAG);
                                }
                                env.account_float_binop(T::get_word_count());
                            }),
                            0b001 => float_op!(T; o = a, b; {
                                if a.is_nan() {
                                    o = b;
                                } else if b.is_nan() {
                                    o = a;
                                } else if a.is_zero() && b.is_zero() {
                                    if b.is_negative() { o = a }
                                    else { o = b }
                                } else {
                                    o = a.max(b);
                                }
                                if a.is_signaling() || b.is_signaling() {
                                    self.accrue_float_exceptions(INVALID_FLAG);
                                }
                                env.account_float_binop(T::get_word_count());
                            }),
                            _ => illegal!(),
                        }
                    },
                    0b01000 => {
                        match (fprecision!(), rs2!()) {
                            // source size -> destination size
                            (0b01, 0b00) if F::SUPPORT_D && env.enable_d() => {
                                // FCVT.D.S
                                fcvt!(Single -> Double);
                            },
                            (0b00, 0b01) if F::SUPPORT_D && env.enable_d() => {
                                // FCVT.S.D
                                fcvt!(Double -> Single);
                            },
                            (0b11, 0b00) if F::SUPPORT_Q && env.enable_q() => {
                                // FCVT.Q.S
                                fcvt!(Single -> Quad);
                            },
                            (0b00, 0b11) if F::SUPPORT_Q && env.enable_q() => {
                                // FCVT.S.Q
                                fcvt!(Quad -> Single);
                            },
                            (0b11, 0b01) if F::SUPPORT_Q && env.enable_q() => {
                                // FCVT.Q.D
                                fcvt!(Double -> Quad);
                            },
                            (0b01, 0b11) if F::SUPPORT_Q && env.enable_q() => {
                                // FCVT.D.Q
                                fcvt!(Quad -> Double);
                            },
                            _ => illegal!(),
                        }
                    },
                    0b10100 => { // FCMP (FEQ, FLT, FLE)
                        match funct3!() {
                            0b000 => float_op!(T; = a, b; {
                                self.put_register(rd!(), (a <= b) as u32);
                                if a.is_nan() || b.is_nan() {
                                    self.accrue_float_exceptions(INVALID_FLAG);
                                }
                                env.account_generic_op();
                            }),
                            0b001 => float_op!(T; = a, b; {
                                self.put_register(rd!(), (a < b) as u32);
                                if a.is_nan() || b.is_nan() {
                                    self.accrue_float_exceptions(INVALID_FLAG);
                                }
                                env.account_generic_op();
                            }),
                            0b010 => float_op!(T; = a, b; {
                                self.put_register(rd!(), (a == b) as u32);
                                if a.is_signaling() || b.is_signaling() {
                                    self.accrue_float_exceptions(INVALID_FLAG);
                                }
                                env.account_generic_op();
                            }),
                            _ => illegal!(),
                        }
                    },
                    0b11000 => {
                        match rs2!() {
                            0b00000 => {
                                // FCVT.W.{S,D,Q}
                                let dst;
                                float_op!(T; = a; {
                                    let mut exact = false;
                                    if a.is_nan() {
                                        dst = i128::MAX;
                                        self.accrue_float_exceptions(INVALID_FLAG);
                                    } else {
                                        dst = float::maybe_unstatus(self, a.to_i128_r(32, round_mode!(), &mut exact));
                                    }
                                    env.account_fcvt_to_int(T::get_word_count());
                                });
                                if dst > i32::MAX as i128 {
                                    self.put_register(rd!(), i32::MAX as u32);
                                } else if dst < i32::MIN as i128 {
                                    self.put_register(rd!(), i32::MIN as u32);
                                } else {
                                    self.put_register(rd!(), dst as u32);
                                }
                            },
                            0b00001 => {
                                // FCVT.WU.{S,D,Q}
                                let dst;
                                float_op!(T; = a; {
                                    let mut exact = false;
                                    if a.is_nan() {
                                        dst = u128::MAX;
                                        self.accrue_float_exceptions(INVALID_FLAG);
                                    } else {
                                        dst = float::maybe_unstatus(self, a.to_u128_r(32, round_mode!(), &mut exact));
                                    }
                                    env.account_fcvt_to_int(T::get_word_count());
                                });
                                if dst > u32::MAX as u128 {
                                    self.put_register(rd!(), u32::MAX as u32);
                                } else {
                                    self.put_register(rd!(), dst as u32);
                                }
                            },
                            _ => illegal!(),
                        }
                    },
                    0b11010 => {
                        match rs2!() {
                            0b00000 => {
                                // FCVT.{S,D,Q}.W
                                let src = self.get_register(rs1!());
                                float_op!(T; o =; {
                                    o = T::from_i128_r(src as i32 as i128, round_mode!());
                                    env.account_fcvt_from_int(T::get_word_count());
                                });
                            },
                            0b00001 => {
                                // FCVT.{S,D,Q}.WU
                                let src = self.get_register(rs1!());
                                float_op!(T; o =; {
                                    o = T::from_u128_r(src as u128, round_mode!());
                                    env.account_fcvt_from_int(T::get_word_count());
                                });
                            },
                            _ => illegal!(),
                        }
                    },
                    0b11100 => match (rs2!(), funct3!()) {
                        (0b00000, 0b000) => {
                            // FMV.X.W
                            let a = F::unbox_single(self.float_registers[rs1!() as usize]);
                            self.put_register(rd!(), a);
                            env.account_generic_op();
                        },
                        (0b00000, 0b001) => {
                            // FCLASS.{S,D,Q}
                            float_op!(T; = a; {
                                let mut o = 0;
                                if a.is_finite() {
                                    match (a.is_negative(), a.is_denormal(), a.is_zero()) {
                                        (true,false,false) => o |= 1<<1,
                                        (true,true,false) => o |= 1<<2,
                                        (true,_,true) => o |= 1<<3,
                                        (false,_,true) => o |= 1<<4,
                                        (false,true,false) => o |= 1<<5,
                                        (false,false,false) => o |= 1<<6,
                                    }
                                } else {
                                    if a.is_neg_infinity() { o |= 1<<0 }
                                    else if a.is_pos_infinity() { o |= 1<<7 }
                                    else if a.is_signaling() { o |= 1<<8 }
                                    else { o |= 1<<9 }
                                }
                                self.put_register(rd!(), o);
                                env.account_generic_op();
                            });
                        },
                        _ => illegal!(),
                    },
                    0b11110 => match (rs2!(), funct3!()) {
                        (0b00000, 0b000) => {
                            // FMV.W.X
                            let a = self.get_register(rs1!());
                            self.float_registers[rd!() as usize] = F::box_single(a);
                            env.account_generic_op();
                        },
                        _ => illegal!(),
                    },
                    _ => illegal!()
                }
            }
            0b11000 => {
                // (BRANCH)
                let a = self.get_register(rs1!());
                let b = self.get_register(rs2!());
                let should_branch = match funct3!() {
                    0b000 => a == b,
                    0b001 => a != b,
                    0b100 => (a as i32) < (b as i32),
                    0b101 => (a as i32) >= (b as i32),
                    0b110 => a < b,
                    0b111 => a >= b,
                    _ => return Err((ExceptionCause::IllegalInstruction,orig_instruction))
                };
                if should_branch {
                    next_pc = this_pc.wrapping_add(imm_b!());
                }
                env.account_branch_op(should_branch, instruction & (1<<31) == 0);
            }
            0b11001 => {
                // JALR
                if funct3!() != 0 {
                    return Err((ExceptionCause::IllegalInstruction,orig_instruction))
                }
                let offset = imm12!();
                let base = self.get_register(rs1!());
                self.put_register(rd!(), next_pc);
                next_pc = base.wrapping_add(offset) & !1;
                env.account_jump_op();
            }
            0b11011 => {
                // JAL
                let offset = imm_j!();
                self.put_register(rd!(), next_pc);
                next_pc = this_pc.wrapping_add(offset);
                env.account_jump_op();
            }
            0b11100 => {
                // SYSTEM
                if funct3!() == 0 {
                    match instruction {
                        0b000000000000_00000_000_00000_1110011 => {
                            // ECALL
                            env.perform_ecall(self)?;
                        }
                        0b000000000001_00000_000_00000_1110011 => {
                            // EBREAK
                            env.perform_ebreak(self)?;
                        }
                        _ => {
                            illegal!()
                        }
                    }
                } else if env.enable_zicsr() {
                    let (handler, source_value, read, write): (fn(u32,u32)->u32, u32, bool, bool) = match funct3!() {
                        // CSRRW
                        0b001 => (|_old_value, new_value| { new_value }, self.get_register(rs1!()), rd!() != 0, true),
                        // CSRRS
                        0b010 => (|old_value, new_value| { old_value | new_value }, self.get_register(rs1!()), true, rs1!() != 0),
                        // CSRRC
                        0b011 => (|old_value, new_value| { old_value & !new_value }, self.get_register(rs1!()), true, rs1!() != 0),
                        // CSRRWI
                        0b101 => (|_old_value, new_value| { new_value }, rs1!(), rd!() != 0, true),
                        // CSRRSI
                        0b110 => (|old_value, new_value| { old_value | new_value }, rs1!(), true, rs1!() != 0),
                        // CSRRCI
                        0b111 => (|old_value, new_value| { old_value & !new_value }, rs1!(), true, rs1!() != 0),
                        _ => {
                            illegal!()
                        }
                    };
                    let old_value = if !read { 0 }
                    else { self.read_csr(env, csr!()).map_err(|x| (x, orig_instruction))? };
                    let new_value = handler(old_value, source_value);
                    if write { self.write_csr(env, csr!(), new_value).map_err(|x| (x, orig_instruction))?; }
                    self.put_register(rd!(), old_value);
                } else {
                    illegal!()
                }
            }
            _ => {
                return Err((ExceptionCause::IllegalInstruction,orig_instruction))
            }
        }
        if (next_pc & 2 == 0) || (Env::SUPPORT_C && env.enable_c()) {
            // the lowest bit is supposed to be ignored, and it's hard to get a
            // 1 in there anyway
            self.put_pc(next_pc & !1);
            Ok(())
        } else {
            Err((ExceptionCause::MisalignedPC, next_pc))
        }
    }
    /// Note that some floating point exceptions have occurred.
    #[allow(unused)]
    fn accrue_float_exceptions(&mut self, exceptions: u32) {
        let fcsr = F::read_csr(&self.fcsr);
        let fcsr = fcsr | (exceptions & 0b11111);
        F::write_csr(&mut self.fcsr, fcsr);
    }
    /// Fetch, decode, and execute a single instruction. `Ok(())` means an
    /// instruction was retired successfully. `Err(...)` means an exception
    /// occurred instead.
    pub fn step<Env: ExecutionEnvironment>(&mut self, env: &mut Env) -> Result<(), Exception> {
        self.internal_step(env)
            .map_err(|(mcause, mtval)| {
                Exception {
                    mcause,
                    mepc: self.get_pc(),
                    mtval
                }
            })
    }
    pub fn read_csr<Env: ExecutionEnvironment>(&mut self, env: &mut Env, csr_number: u32) -> Result<u32, ExceptionCause> {
        if F::SUPPORT_F && env.enable_f() {
            match csr_number {
                0x001 => return Ok(self.read_fflags()),
                0x002 => return Ok(self.read_frm()),
                0x003 => return Ok(self.read_fcsr()),
                _ => (),
            }
        }
        env.read_csr(csr_number)
    }
    pub fn write_csr<Env: ExecutionEnvironment>(&mut self, env: &mut Env, csr_number: u32, new_value: u32) -> Result<(), ExceptionCause> {
        if F::SUPPORT_F && env.enable_f() {
            match csr_number {
                0x001 => return Ok(self.write_fflags(new_value)),
                0x002 => return Ok(self.write_frm(new_value)),
                0x003 => return Ok(self.write_fcsr(new_value)),
                _ => (),
            }
        }
        env.write_csr(csr_number, new_value)
    }
    /// Read the `fflags` CSR.
    pub fn read_fflags(&self) -> u32 {
        F::read_csr(&self.fcsr) & 0b11111
    }
    /// Read the `frm` CSR.
    pub fn read_frm(&self) -> u32 {
        (F::read_csr(&self.fcsr) >> 5) & 0b111
    }
    /// Read the `fcsr` CSR.
    pub fn read_fcsr(&self) -> u32 {
        F::read_csr(&self.fcsr)
    }
    /// Write the `fflags` CSR.
    pub fn write_fflags(&mut self, new_value: u32) {
        let new_value = (F::read_csr(&self.fcsr) & !0b11111) | (new_value & 0b11111);
        F::write_csr(&mut self.fcsr, new_value)
    }
    /// Write the `frm` CSR.
    pub fn write_frm(&mut self, new_value: u32) {
        let new_value = (F::read_csr(&self.fcsr) & !0b111_00000) | ((new_value & 0b111) << 5);
        F::write_csr(&mut self.fcsr, new_value)
    }
    /// Write the `fcsr` CSR.
    pub fn write_fcsr(&mut self, new_value: u32) {
        F::write_csr(&mut self.fcsr, new_value & 0b111_11111)
    }
}

// Convert from memory exceptions to the appropriate `MachineException`
fn map_ifetch<T>(address: u32, x: Result<T,MemoryAccessFailure>) -> Result<T,(ExceptionCause,u32)> {
    match x {
        Err(MemoryAccessFailure::Unaligned) => Err((ExceptionCause::MisalignedPC, address)),
        Err(MemoryAccessFailure::Fault) => Err((ExceptionCause::InstructionFault, address)),
        Ok(x) => Ok(x),
    }
}
fn map_load<T>(address: u32, x: Result<T,MemoryAccessFailure>) -> Result<T,(ExceptionCause,u32)> {
    match x {
        Err(MemoryAccessFailure::Unaligned) => Err((ExceptionCause::MisalignedLoad, address)),
        Err(MemoryAccessFailure::Fault) => Err((ExceptionCause::LoadFault, address)),
        Ok(x) => Ok(x),
    }
}
fn map_store<T>(address: u32, x: Result<T,MemoryAccessFailure>) -> Result<T,(ExceptionCause,u32)> {
    match x {
        Err(MemoryAccessFailure::Unaligned) => Err((ExceptionCause::MisalignedStore, address)),
        Err(MemoryAccessFailure::Fault) => Err((ExceptionCause::StoreFault, address)),
        Ok(x) => Ok(x),
    }
}

#[cfg(test)]
mod test {
    use super::*;
    #[test] fn cpu_base_size() {
        let size = std::mem::size_of::<Cpu<()>>();
        if size != 128 { panic!("Cpu<()> should be 128 bytes, was {size}!")}
    }
    #[cfg(feature="float")]
    #[test] fn cpu_f_size() {
        let size = std::mem::size_of::<Cpu<u32>>();
        if size != 260 { panic!("Cpu<u32> should be 260 bytes, was {size}!")}
    }
    #[cfg(feature="float")]
    #[test] fn cpu_d_size() {
        let size = std::mem::size_of::<Cpu<u64>>();
        if size != 388 && size != 392 { panic!("Cpu<u64> should be 388 or 392 bytes, was {size}!")}
    }
    #[cfg(feature="float")]
    #[test] fn cpu_q_size() {
        let size = std::mem::size_of::<Cpu<u128>>();
        if size != 644 && size != 648 && size != 656 { panic!("Cpu<u128> should be 644 or 648 or 656 bytes, was {size}!")}
    }
}