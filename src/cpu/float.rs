//! Black magic to support any level of standard floating point.

#[cfg(feature = "float")]
pub use rustc_apfloat::{
    ieee::{Double, Quad, Single},
    Float, FloatConvert, Status, StatusAnd,
};

// The RISC-V specification decrees that all NaNs generated by the CPU shall
// have these exact bit values.
#[cfg(feature = "float")]
pub const CANON_NAN_32: u32 = 0x7fc00000;
#[cfg(feature = "float")]
pub const CANON_NAN_64: u64 = 0x7ff80000_00000000;
#[cfg(feature = "float")]
pub const CANON_NAN_128: u128 = 0x7fff8000_00000000_00000000_00000000;

// RNE rounding mode, no accrued exceptions
#[cfg(feature = "float")]
const DEFAULT_CSR: u8 = 0b000_00000;
// exceptions!
#[cfg(feature = "float")]
pub const INVALID_FLAG: u8 = 0b10000;
#[cfg(feature = "float")]
pub const ZERO_DIV_FLAG: u8 = 0b01000;
#[cfg(feature = "float")]
pub const OVERFLOW_FLAG: u8 = 0b00100;
#[cfg(feature = "float")]
pub const UNDERFLOW_FLAG: u8 = 0b00010;
#[cfg(feature = "float")]
pub const INEXACT_FLAG: u8 = 0b00001;

pub trait FloatStatusTrait: Default + Clone {
    fn set_bits(&mut self, bits: u8);
    fn get_bits(&self) -> u8;
    fn make_dirty(&mut self);
    fn is_active(&self) -> bool;
}

impl FloatStatusTrait for () {
    fn set_bits(&mut self, _bits: u8) {
        // do nothing
    }
    fn get_bits(&self) -> u8 {
        0b00
    }
    fn make_dirty(&mut self) {
        // do nothing
    }
    fn is_active(&self) -> bool {
        false
    }
}

#[doc(hidden)]
#[derive(Clone, Copy)]
pub struct FloatStatus(u8);

impl FloatStatusTrait for FloatStatus {
    fn set_bits(&mut self, bits: u8) {
        self.0 = bits
    }
    fn get_bits(&self) -> u8 {
        self.0
    }
    fn make_dirty(&mut self) {
        self.0 = 0b11
    }
    fn is_active(&self) -> bool {
        self.0 != 0
    }
}

impl Default for FloatStatus {
    fn default() -> FloatStatus {
        FloatStatus(0b11)
    }
}

/// This trait is implemented by all four possible type parameters of
/// [`Cpu<F>`](super::Cpu). You should not try to implement it yourself.
/// Instead, you should use one of the four provided implementations.
///
/// - `()`: no floating point support
/// - `u32`: 32-bit floating point support only
/// - `u64`: 32- and 64-bit floating point support
/// - `u128`: 32-, 64-, and 128-bit floating point support
///
/// Nothing inside this trait is considered part of the public-facing API.
/// Non-compatible changes may be made even on patch releases. Depend on this
/// trait's innards at your own risk.
pub trait FloatBits: Default + Copy + PartialEq + Eq {
    /// Must be equal to `std::mem::size_of::<Self>()`.
    const BYTES_PER_FLOAT: usize;
    /// True if this `FloatBits` can fit a 32-bit float.
    const SUPPORT_F: bool = false;
    /// True if this `FloatBits` can fit a 64-bit float.
    const SUPPORT_D: bool = false;
    /// True if this `FloatBits` can fit a 128-bit float.
    const SUPPORT_Q: bool = false;
    /// Cram a 32-bit float into this `FloatBits`.
    fn box_single(_input: u32) -> Self {
        unreachable!()
    }
    /// Extract a 32-bit float from this `FloatBits`.
    fn unbox_single(self) -> u32 {
        unreachable!()
    }
    /// Cram a 64-bit float into this `FloatBits`.
    fn box_double(_input: u64) -> Self {
        unreachable!()
    }
    /// Extract a 64-bit float from this `FloatBits`.
    fn unbox_double(self) -> u64 {
        unreachable!()
    }
    /// Cram a 128-bit float into this `FloatBits`.
    fn box_quad(_input: u128) -> Self {
        unreachable!()
    }
    /// Extract a 128-bit float from this `FloatBits`.
    fn unbox_quad(self) -> u128 {
        unreachable!()
    }
    /// Type that should be used to store the `fcsr` value; `u8` if floats are
    /// supported, `()` if not.
    type CsrType;
    /// Type that should be used to store the `fstatus` value; `u8` if floats
    /// are supported, `()` if not.
    type StatusType: FloatStatusTrait;
    /// Default value of `fcsr`.
    fn default_csr() -> Self::CsrType;
    /// Extract the current value of `fcsr`.
    fn read_csr(csr: &Self::CsrType) -> u8;
    /// Overwrite the current value of `fcsr`.
    fn write_csr(csr: &mut Self::CsrType, value: u8);
    /// Marshal this `FloatBits` into `BYTES_PER_FLOAT` big-endian bytes.
    /// (As an array of 16 bytes, currently.)
    fn to_bytes(&self) -> [u8; 16];
    /// Recover this `FloatBits` from `BYTES_PER_FLOAT` big-endian bytes
    /// previously acquired from calling [`to_bytes`](Self::to_bytes).
    fn from_bytes(b: &[u8]) -> Self;
}

impl FloatBits for () {
    const BYTES_PER_FLOAT: usize = 0;
    type CsrType = ();
    type StatusType = ();
    fn default_csr() {}
    fn read_csr(_: &()) -> u8 {
        0
    }
    fn write_csr(_: &mut (), _value: u8) {}
    fn to_bytes(&self) -> [u8; 16] {
        [0; 16]
    }
    fn from_bytes(_b: &[u8]) -> Self {}
}

#[cfg(feature = "float")]
impl FloatBits for u32 {
    const BYTES_PER_FLOAT: usize = 4;
    const SUPPORT_F: bool = true;
    fn box_single(input: u32) -> Self {
        input
    }
    fn unbox_single(self) -> u32 {
        self
    }
    type CsrType = u8;
    type StatusType = FloatStatus;
    fn default_csr() -> u8 {
        DEFAULT_CSR
    }
    fn read_csr(csr: &u8) -> u8 {
        *csr
    }
    fn write_csr(csr: &mut u8, value: u8) {
        *csr = value
    }
    fn to_bytes(&self) -> [u8; 16] {
        let b = self.to_be_bytes();
        [b[0], b[1], b[2], b[3], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    }
    fn from_bytes(b: &[u8]) -> Self {
        Self::from_be_bytes([b[0], b[1], b[2], b[3]])
    }
}

#[cfg(feature = "float")]
impl FloatBits for u64 {
    const BYTES_PER_FLOAT: usize = 8;
    const SUPPORT_F: bool = true;
    const SUPPORT_D: bool = true;
    fn box_single(input: u32) -> Self {
        input as u64 | !(u32::MAX as u64)
    }
    fn unbox_single(self) -> u32 {
        self as u32
    }
    fn box_double(input: u64) -> Self {
        input
    }
    fn unbox_double(self) -> u64 {
        self
    }
    type CsrType = u8;
    type StatusType = FloatStatus;
    fn default_csr() -> u8 {
        DEFAULT_CSR
    }
    fn read_csr(csr: &u8) -> u8 {
        *csr
    }
    fn write_csr(csr: &mut u8, value: u8) {
        *csr = value
    }
    fn to_bytes(&self) -> [u8; 16] {
        let b = self.to_be_bytes();
        [
            b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7], 0, 0, 0, 0, 0, 0,
            0, 0,
        ]
    }
    fn from_bytes(b: &[u8]) -> Self {
        Self::from_be_bytes([b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]])
    }
}

#[cfg(feature = "float")]
impl FloatBits for u128 {
    const BYTES_PER_FLOAT: usize = 16;
    const SUPPORT_F: bool = true;
    const SUPPORT_D: bool = true;
    const SUPPORT_Q: bool = true;
    fn box_single(input: u32) -> Self {
        input as u128 | !(u32::MAX as u128)
    }
    fn unbox_single(self) -> u32 {
        self as u32
    }
    fn box_double(input: u64) -> Self {
        input as u128 | !(u64::MAX as u128)
    }
    fn unbox_double(self) -> u64 {
        self as u64
    }
    fn box_quad(input: u128) -> Self {
        input
    }
    fn unbox_quad(self) -> u128 {
        self
    }
    type CsrType = u8;
    type StatusType = FloatStatus;
    fn default_csr() -> u8 {
        DEFAULT_CSR
    }
    fn read_csr(csr: &u8) -> u8 {
        *csr
    }
    fn write_csr(csr: &mut u8, value: u8) {
        *csr = value
    }
    fn to_bytes(&self) -> [u8; 16] {
        self.to_be_bytes()
    }
    fn from_bytes(b: &[u8]) -> Self {
        Self::from_be_bytes([
            b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7], b[8], b[9], b[10],
            b[11], b[12], b[13], b[14], b[15],
        ])
    }
}

#[cfg(feature = "float")]
pub fn to_single(bits: u32) -> Single {
    Single::from_bits(bits as u128)
}

#[cfg(feature = "float")]
pub fn to_double(bits: u64) -> Double {
    Double::from_bits(bits as u128)
}

#[cfg(feature = "float")]
pub fn to_quad(bits: u128) -> Quad {
    Quad::from_bits(bits)
}

#[cfg(feature = "float")]
pub trait MaybeUnstatus {
    type Inner;
    fn with_status(&self, handler: impl FnOnce(&Status));
    fn to_inner(self) -> Self::Inner;
}

#[cfg(feature = "float")]
impl<T> MaybeUnstatus for StatusAnd<T> {
    type Inner = T;
    fn with_status(&self, handler: impl FnOnce(&Status)) {
        handler(&self.status);
    }
    fn to_inner(self) -> T {
        self.value
    }
}

#[cfg(feature = "float")]
impl MaybeUnstatus for Single {
    type Inner = Self;
    fn with_status(&self, _: impl FnOnce(&Status)) {}
    fn to_inner(self) -> Self {
        self
    }
}

#[cfg(feature = "float")]
impl MaybeUnstatus for Double {
    type Inner = Self;
    fn with_status(&self, _: impl FnOnce(&Status)) {}
    fn to_inner(self) -> Self {
        self
    }
}

#[cfg(feature = "float")]
impl MaybeUnstatus for Quad {
    type Inner = Self;
    fn with_status(&self, _: impl FnOnce(&Status)) {}
    fn to_inner(self) -> Self {
        self
    }
}

#[cfg(feature = "float")]
pub fn maybe_unstatus<T: MaybeUnstatus, F: FloatBits>(
    cpu: &mut super::Cpu<F>,
    x: T,
) -> T::Inner {
    x.with_status(|status| {
        // unlucky us, rustc_apfloat defines these in the opposite order as the
        // RISC-V spec does
        let mut q = 0;
        if status.contains(Status::INVALID_OP) {
            q |= INVALID_FLAG;
        }
        if status.contains(Status::DIV_BY_ZERO) {
            q |= ZERO_DIV_FLAG;
        }
        if status.contains(Status::OVERFLOW) {
            q |= OVERFLOW_FLAG;
        }
        if status.contains(Status::UNDERFLOW) {
            q |= UNDERFLOW_FLAG;
        }
        if status.contains(Status::INEXACT) {
            q |= INEXACT_FLAG;
        }
        if q != 0 {
            cpu.accrue_float_exceptions(q)
        }
    });
    x.to_inner()
}

#[cfg(feature = "float")]
pub trait WordyFloat {
    fn get_word_count() -> u32;
}

#[cfg(feature = "float")]
impl WordyFloat for Single {
    fn get_word_count() -> u32 {
        1
    }
}

#[cfg(feature = "float")]
impl WordyFloat for Double {
    fn get_word_count() -> u32 {
        2
    }
}

#[cfg(feature = "float")]
impl WordyFloat for Quad {
    fn get_word_count() -> u32 {
        4
    }
}
