//! Black magic to support any level of standard floating point.

pub use rustc_apfloat::{
    Float, Status, StatusAnd,
    ieee::{Single, Double, Quad},
};

// The RISC-V specification decrees that all NaNs generated by the CPU shall
// have these exact bit values.
pub const CANON_NAN_32: u32 = 0x7fc00000;
pub const CANON_NAN_64: u64 = 0x7ff80000_00000000;
pub const CANON_NAN_128: u128 = 0x7fff8000_00000000_00000000_00000000;

// RMM rounding mode, no accrued exceptions
const DEFAULT_CSR: u32 = 0b100_00000;
// exceptions!
pub const INVALID_FLAG: u32 = 0b10000;
pub const ZERO_DIV_FLAG: u32 = 0b01000;
pub const OVERFLOW_FLAG: u32 = 0b00100;
pub const UNDERFLOW_FLAG: u32 = 0b00010;
pub const INEXACT_FLAG: u32 = 0b00001;

pub trait FloatBits : Default + Copy {
    const SUPPORT_F: bool = false;
    const SUPPORT_D: bool = false;
    const SUPPORT_Q: bool = false;
    fn box_single(_input: u32) -> Self { unreachable!() }
    fn unbox_single(self) -> u32 { unreachable!() }
    fn box_double(_input: u64) -> Self { unreachable!() }
    fn unbox_double(self) -> u64 { unreachable!() }
    fn box_quad(_input: u128) -> Self { unreachable!() }
    fn unbox_quad(self) -> u128 { unreachable!() }
    type CsrType;
    fn default_csr() -> Self::CsrType;
    fn read_csr(csr: &Self::CsrType) -> u32;
    fn write_csr(csr: &mut Self::CsrType, value: u32);
}

impl FloatBits for () {
    type CsrType = ();
    fn default_csr() {}
    fn read_csr(_: &()) -> u32 { 0 }
    fn write_csr(_: &mut (), _value: u32) {}
}

impl FloatBits for u32 {
    const SUPPORT_F: bool = true;
    fn box_single(input: u32) -> Self { input }
    fn unbox_single(self) -> u32 { self }
    type CsrType = u32;
    fn default_csr() -> u32 { DEFAULT_CSR }
    fn read_csr(csr: &u32) -> u32 { *csr }
    fn write_csr(csr: &mut u32, value: u32) { *csr = value }
}

impl FloatBits for u64 {
    const SUPPORT_F: bool = true;
    const SUPPORT_D: bool = true;
    fn box_single(input: u32) -> Self { input as u64 | !(u32::MAX as u64) }
    fn unbox_single(self) -> u32 { self as u32 }
    fn box_double(input: u64) -> Self { input }
    fn unbox_double(self) -> u64 { self }
    type CsrType = u32;
    fn default_csr() -> u32 { DEFAULT_CSR }
    fn read_csr(csr: &u32) -> u32 { *csr }
    fn write_csr(csr: &mut u32, value: u32) { *csr = value }
}

impl FloatBits for u128 {
    const SUPPORT_F: bool = true;
    const SUPPORT_D: bool = true;
    const SUPPORT_Q: bool = true;
    fn box_single(input: u32) -> Self { input as u128 | !(u32::MAX as u128) }
    fn unbox_single(self) -> u32 { self as u32 }
    fn box_double(input: u64) -> Self { input as u128 | !(u64::MAX as u128) }
    fn unbox_double(self) -> u64 { self as u64 }
    fn box_quad(input: u128) -> Self { input }
    fn unbox_quad(self) -> u128 { self }
    type CsrType = u32;
    fn default_csr() -> u32 { DEFAULT_CSR }
    fn read_csr(csr: &u32) -> u32 { *csr }
    fn write_csr(csr: &mut u32, value: u32) { *csr = value }
}

pub fn to_single(bits: u32) -> Single {
    Single::from_bits(bits as u128)
}

pub fn to_double(bits: u64) -> Double {
    Double::from_bits(bits as u128)
}

pub fn to_quad(bits: u128) -> Quad {
    Quad::from_bits(bits as u128)
}

pub trait MaybeUnstatus {
    type Inner;
    fn with_status(&self, handler: impl FnOnce(&Status));
    fn to_inner(self) -> Self::Inner;
}

impl<T> MaybeUnstatus for StatusAnd<T> {
    type Inner = T;
    fn with_status(&self, handler: impl FnOnce(&Status)) {
        handler(&self.status);
    }
    fn to_inner(self) -> T { self.value }
}

impl MaybeUnstatus for Single {
    type Inner = Self;
    fn with_status(&self, _: impl FnOnce(&Status)) {}
    fn to_inner(self) -> Self { self }
}

impl MaybeUnstatus for Double {
    type Inner = Self;
    fn with_status(&self, _: impl FnOnce(&Status)) {}
    fn to_inner(self) -> Self { self }
}

impl MaybeUnstatus for Quad {
    type Inner = Self;
    fn with_status(&self, _: impl FnOnce(&Status)) {}
    fn to_inner(self) -> Self { self }
}

pub fn maybe_unstatus<T: MaybeUnstatus, F: FloatBits>(cpu: &mut super::Cpu<F>, x: T) -> T::Inner {
    x.with_status(|status| {
        // unlucky us, rustc_apfloat defines these in the opposite order as the
        // RISC-V spec does
        let mut q = 0;
        if status.contains(Status::INVALID_OP) { q |= INVALID_FLAG; }
        if status.contains(Status::DIV_BY_ZERO) { q |= ZERO_DIV_FLAG; }
        if status.contains(Status::OVERFLOW) { q |= OVERFLOW_FLAG; }
        if status.contains(Status::UNDERFLOW) { q |= UNDERFLOW_FLAG; }
        if status.contains(Status::INEXACT) { q |= INEXACT_FLAG; }
        if q != 0 { cpu.float_exceptions(q) }
    });
    x.to_inner()
}

pub trait WordyFloat {
    fn get_word_count() -> u32;
}

impl WordyFloat for Single {
    fn get_word_count() -> u32 { 1 }
}

impl WordyFloat for Double {
    fn get_word_count() -> u32 { 2 }
}

impl WordyFloat for Quad {
    fn get_word_count() -> u32 { 4 }
}